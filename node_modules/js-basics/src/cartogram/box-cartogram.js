/* @requires shapes, data, arrayutils */

var BoxCartogram = (function() {
  var api = {};

  api.createBoxShapes = function(data, fRow, fCol) {

    var records = data.getRecordSet();
    var bb = new BoundingBox();
    var shapes = [];
    while(records.hasNext()) {
      var rec = records.nextRecord;
      var row = rec.get(fRow);
      var col = rec.get(fCol);

      var yy = [row - 1, row, row, row -1, row-1];
      var xx = [col, col, col-1, col-1, col];
      var vec = new VertexSet(xx, yy);
      vec.calcBounds();
      bb.mergeBounds(vec);
      var shp = new ShapeVector(shapes.length, vec);
      shapes.push(shp);
    }

    return {shapes: shapes, polygons:true, bounds:bb};
  };


  function getSegmentKey(x0, y0, x1, y1) {
    var reversed = x0 > x1 || y0 > y1;
    var key = reversed ? x0 + ',' + y0 + '-' + x1 + ',' + y1 : x1 + ',' + y1 + '-' + x0 + ',' + y0;
    return key;
  }

  function Segment(row, col, side) {
    var x = col;
    var y = row;

    var x0 = side != 'r' ? x - 1 : x
    var y0 = side != 't' ? y - 1 : y;
    var x1 = side == 'l' ? x - 1 : x;
    var y1 = side == 'b' ? y - 1 : y;

    this.key = getSegmentKey(x0, y0, x1, y1);
    this.p0 = new Point(x0, y0);
    this.p1 = new Point(x1, y1);

  }

  function createMergedShape(set, fRow, fCol, shapeId) {
    var segIndex = {};
    var indexSize = 0;

    function getASegment() {
      for (var key in segIndex) {
        return getSegmentByKey(key);
      }
      return null;
    }

    function getSegmentByKey(key) {
      var seg = segIndex[key];
      if (!seg) {
        return null;
      }

      indexSize--;
      delete segIndex[key];
      return seg;
    }

    function getNextSegment(x, y) {
      var key = getSegmentKey(x, y, x + 1, y);
      if (key in segIndex == false) {
        key = getSegmentKey(x, y, x, y+1);
        if (key in segIndex == false) {
          key = getSegmentKey(x, y, x-1, y);
          if (key in segIndex == false) {
            key = getSegmentKey(x, y, x, y-1);
          }
        }
      }

      //trace("getNextSegment() key:", key);

      if (!key) {
        return null;
      }

      return getSegmentByKey(key);
    }

    function addSegment(r, c, side) {
      var seg = new Segment(r, c, side);

      if (seg.key in segIndex) {
        var type = "(-)"
        delete segIndex[seg.key];
        indexSize --;
      } else {
        type = "(+)";
        segIndex[seg.key] = seg;
        indexSize ++;
      }

    }

    while(set.hasNext()) {
      var rec = set.nextRecord;
      var row = rec.get(fRow);
      var col = rec.get(fCol);

      addSegment(row, col, 't');
      addSegment(row, col, 'b');
      addSegment(row, col, 'r');
      addSegment(row, col, 'l');
    }
    
    // traverse, build shape
    var points;
    var parts = [];
    var prevPoint;
    var seg;

    while(seg = getASegment()) {
      if (points) {
        parts.push(points);
      }
      points = [seg.p0];
      prevPoint = seg.p1;

      while(true) {
        points.push(prevPoint);

        // get next segment
        var nextSeg = getNextSegment(prevPoint.x, prevPoint.y);

        if (!nextSeg) {
          break;
        }

        if (nextSeg.p0.equals(prevPoint)) {
          prevPoint = nextSeg.p1;
        } else {
          prevPoint = nextSeg.p0;
        }
      }
    }

    if (points) {
      parts.push(points);
    }

    // make shape
    if (parts.length == 0) {
      trace("[createStateShape()] null shape for shapeId:", shapeId);
      return null;
    }

    var shp;
    for (var i=0; i<parts.length; i++) {
      var points = parts[i];
      var xx = [];
      var yy = [];
      Utils.forEach(points, function(p) {
        xx.push(p.x);
        yy.push(p.y);
      });
      var vec = new VertexSet(xx, yy);
      vec.calcBounds();

      if (i == 0) {
        shp = new ShapeVector(shapeId, vec);
      } else {
        shp.addPartData(vec);
      }

      return shp;
    }
  }

  function findBoundaries(shapes) {
    var segIndex = {};
    var boundaries = [];

    Utils.forEach(shapes, function(shp) {
      var parts = shp.parts;
      for (var i=0; i<parts.length; i++) {
        var ring = parts[i];
        var shp, vec, x, y, prevX, prevY;
        var inShape = false;
        if (ring.hasNext()) {
          x = ring.nextX;
          y = ring.nextY;

          while(ring.hasNext()) {
            prevX = x;
            prevY = y;
            x = ring.nextX;
            y = ring.nextY;
            var key = getSegmentKey(prevX, prevY, x, y);

            // shared segment
            if (segIndex[key]) {
              if (inShape) {
                vec.xx.push(x);
                vec.yy.push(y);
              }
              else {
                inShape = true;
                vec = new VertexSet([prevX, x], [prevY, y]);
              }
            }

            // shared segment not encountered
            else {
              segIndex[key] = true;
              if (inShape) {
                inShape = false;
                vec.calcBounds();
                shp = new ShapeVector(boundaries.length, vec);
                boundaries.push(shp);
              }
            }
          }
        }


        if (inShape) {
          vec.calcBounds();
          shp = new ShapeVector(boundaries.length, vec);
          boundaries.push(shp);
        }

      } // end part



    }); // end forEach

    return boundaries;

  }


  api.createMergedShapes = function(table, fKey, fRow, fCol) {


    var bounds = new BoundingBox();
    var shapes = [];

    // merge shapes
    //
    var keys = table.getFieldData(fKey);
    keys = Utils.uniqueArray(keys);
    Utils.forEach(keys, function(key, i) {
      var set = table.getMatchingRecordSet(fKey, key);
      var shp = createMergedShape(set, fRow, fCol, i);
      shapes.push(shp);
      if (shp) {
        bounds.mergeBounds(shp);
      }
    });

    // identify boundaries
    //
    var boundaries = findBoundaries(shapes);

    var obj = {
      boundaries:boundaries,
      polygons: true,
      bounds: bounds,
      shapes: shapes
    };

    return obj;    
  };

  return api;

})();
