/* @requires events, core, arrayutils */

var inNode = typeof module !== 'undefined' && !!module.exports;
var Node = {
  // TODO: remove redundancy w/ browser.js
  inNode: inNode,
  arguments: inNode ? process.argv.slice(1) : null // remove "node" from head of argv list
};


/**
 * Convenience functions for working with files and loading data.
 */
if (inNode) {
  Node.fs = require('fs');

  Node.gc = function() {
    global.gc && global.gc();
  };

  Node.statSync = function(fpath) {
    var obj = null;
    try {
      obj = Node.fs.statSync(fpath);  
    } 
    catch(e) {
      //trace(e, fpath);
    }
    return obj;
  };

  // path is relative to the node script;
  // get the absolute path to it.
  //
  Node.absPath = function(path) {
    var scriptDir = Node.getFileInfo(require.main.filename).directory;
    return require('path').join(scriptDir, path);
  };

  Node.dirExists = function(path) {
    var ss = Node.statSync(path);
    return ss && ss.isDirectory() || false;
  };

  Node.fileExists = function(path) {
    var ss = Node.statSync(path);
    return ss && ss.isFile() || false;
  };

  Node.parseFilename = function(fpath) {
    // TODO: give meaningful output if fpath is a directory
    var path = require('path'),
        info = {};
    info.file = path.basename(fpath);
    info.path = path.resolve(fpath);
    info.ext = path.extname(fpath).toLowerCase().slice(1);
    info.base = info.ext.length > 0 ? info.file.slice(0, -info.ext.length - 1) : info.file;
    info.directory = path.dirname(info.path);
    return info;
  };

  Node.getFileInfo = function(fpath) {
    var info = Node.parseFilename(fpath);
    info.exists = Node.fileExists(fpath);
    return info;
  };

  /**
   * @param charset (optional) 'utf8' to read a string; if undefined, returns Buffer
   * @returns String if charset is provided, *** else Buffer object (node-specific object) ****
   */
  Node.readFile = function(fname, charset) {
    try {
      var content = Node.fs.readFileSync(fname, charset || void 0);
    } catch(e) {
      content = "";
      trace("[Node.readFile()] Error reading file:", fname, "err:", e);
    }
    return content;
  };

  Node.writeFile = function(path, content) {
    Node.fs.writeFile(path, content, function(err) {
      if (err) {
        trace("[Node.writeFile()] Failed to write to file:", path);
      }
    });
  };

  Node.copyFile = function(src, dest) {
    assert(Node.fileExists(src), "[copyFile()] File not found:", src);
    var content = Node.fs.readFileSync(src);
    Node.fs.writeFileSync(dest, content);
  };

  Node.loadUrl = function(url) {
    return new NodeUrlLoader(url);
  };

  // super-simple options, if not using optimist
  Node.options = function(o) {
    o = o || {};
    var opts = {_:[]},
        flags = Utils.isString(o.flags) ? o.flags.split('') : [],
        currOpt;

    Node.arguments.splice(1).forEach(function(arg) {
      var match;
      if (match = /^-(.)/.exec(arg)) {
        currOpt = match[1];
        if (Utils.contains(flags, currOpt)) {
          opts[currOpt] = true; 
        }
      } else if (currOpt) {
        opts[currOpt] = Utils.isNumber(arg) ? parseFloat(arg) : arg;
        currOpt = null;
      } else {
        opts._.push(arg);
      }
    });
    return opts;
  };
}

function NodeUrlLoader(url) {
  var self = this,
    body = "",
    output,
    opts = Utils.parseUrl(url);
  delete opts.protocol;
  opts.port = 80;
  
  require('http').get(opts, function(resp) {
    if (resp.headers['content-encoding'] == 'gzip') {
      var gzip = zlib.createGunzip();
      resp.pipe(gzip);
      output = gzip;
    } else {
      output = resp;
    }
    output.on('data', function(chunk) {
      body += chunk;
    });
    output.on('end', function() {
      self.data = body;
      self.startWaiting();    
    });

  }).on("error", function(e){
    trace("[NodeUrlLoader] error: " + e.message);
  });
}

Opts.inherit(NodeUrlLoader, Waiter);