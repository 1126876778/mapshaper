/** @requires core */

/**
 * An event object, used by EventDispatcher, passed to event handlers.
 * @param {string} type Event name.
 * @param {*} target Object dispatching the event.
 * @param {function(BoundEvent)} callback Event handler function.
 * @param {*} context Execution context of the callback.
 * @param {number} priority Priority of the event.
 * @constructor
 */
function BoundEvent(type, target, callback, context, priority) {
  this.type = type;
  this.target = target;
  this.callback = callback;
  this.context = context;
  this.priority = priority | 0;

  if (typeof(callback) != 'function') {
    trace("[BoundEvent] Error: callback is not a function; event:", this, "target:", target, "Callback:", callback);
  }
}

/**
 * Call a single, bound event handler.
 * @param {object=} obj Optional data to send with the event.
 */
BoundEvent.prototype.trigger = function(obj) {
  // Merge any data into the event object for handler to use (if present).
  if (obj) {
    // TODO: Protect basic BoundEvent properties like target, etc.
    Opts.copyAllParams(this, obj);  // mix in the data; update params; WARNING: breaks when mixing in another event
    this.data = obj;  // Also add data as a property; for tracing, also makes it easy to proxy events.
  }
  this.callback.call(this.context, this);
};


/**
 * Returns debugging string.
 * @return {string} String.
 */
/* */
BoundEvent.prototype.toString = function() {
  var str = 'type:' + this.type + ', target: ' + Utils.strval(this.target);
  if (this.data) {
    str += ', data:' + Utils.strval(this.data);
  }
  str = '[BoundEvent]: {' + str + '}';
  return str;
};



/**
 * Base class for objects that dispatch events; public methods:
 *   addEventListener() / on()
 *   removeEventListener()
 *   dispatchEvent() / trigger()
 *
 * @constructor
 */
function EventDispatcher() {}

/**
 * Dispatch an event (i.e. all registered event handlers are called).
 * @param {string} type Name of the event type, e.g. "change".
 * @param {object=} obj Optional data to send with the event.
 */
EventDispatcher.prototype.dispatchEvent = EventDispatcher.prototype.trigger = function(type, obj, ctx) {

  if (typeof type != 'string') {
    trace('[dispatchEvent()] requires a string argument; type:', type, "data:", obj, "target:", ctx);
    return;
  }

  // (this._firedTypes || (this._firedTypes = {}))[type] = true;

  var listeners = this._listeners;
  if (listeners) {
    for (var i = 0, len = listeners.length; i < len; i++) {
      var evt = listeners[i];
      if (evt.type == type && (!ctx || evt.context == ctx)) {
        evt.trigger(obj);
        /*
        try {
          evt.trigger(obj);
        }
        catch (err) {
          trace("[EventDispatcher.dispatchEvent()]: ## Error in", evt.context, "--", err, "-- Event:", type, " Handler:\n", evt.callback.toString(), "hander context:",  "data:", obj);
        }
        */
      }
    }

    if (type == 'ready') {
      this.removeEventListeners(type, null, ctx);
    }
  }
};



/**
 * Test whether a type of event has been fired.
 * @param {string} type Event type.
 * @return {boolean} True if event was fired else false.
 */
/*
EventDispatcher.prototype.eventHasFired = function(type) {
  return !!this._firedTypes && this._firedTypes[type] == true;
};
*/

/**
 * Register an event handler for a named event.
 * @param {string} type Name of the event.
 * @param {function} callback Event handler, called with BoundEvent argument.
 * @param {*} context Execution context of the event handler.
 * @param {number} priority Priority of the event; defaults to 0.
 * removed * @return True if handler added, else false.
 */
EventDispatcher.prototype.on = EventDispatcher.prototype.addEventListener =
  function(type, callback, context, priority) {
  if (!context) {
    //trace('[EventDispatcher.addEventListener()] Warning, called without context; type:',
    //  type + ' this: ' + Utils.strval(this));
    context = this;
  }

  priority = priority || 0;
  var evt = new BoundEvent(type, this, callback, context, priority);

  // Special case: 'ready' handler fires immediately if target is already ready.
  // (Applicable to Waiter class objects)
  //
  if (type == 'ready' && this._ready) {
    // trace("Warning: Waiter.waitFor() no longer uses this; this:", this, "handler ctx:", context);
    evt.trigger();
    return this;
  }

  // Insert the new event in the array of listeners according to its priority.
  //
  var listeners = this._listeners || (this._listeners = []);
  var idx = 0;
  for (var i = 0, len = listeners.length; i < len; i++) {
    var priorEvent = listeners[i];
    if (priorEvent.type == evt.type && priorEvent.callback == evt.callback &&
      priorEvent.context == evt.context) {
      trace("*** [EventDispatcher.addEventListener()] Found duplicate event, skipping. Type:", type, "ctx:", context, "this:", this );
      return this;
    }
    if (evt.priority <= priorEvent.priority) {
      idx = i + 1;
    }
  }
  listeners.splice(idx, 0, evt);
  return this;
};


EventDispatcher.prototype.countEventListeners = function(type) {
  var listeners = this._listeners,
    len = listeners && listeners.length || 0,
    count = 0;
  if (!type) return len;
  for (var i = 0; i < len; i++) {
    if (listeners[i].type === type) count++;
  }
  return count;
};

/**
 * Remove an event listener.
 * @param {string} type Event type to match.
 * @param {function(BoundEvent)} callback Event handler function to match.
 * @param {*=} context Execution context of the event handler to match.
 * @return {number} Returns number of listeners removed (expect 0 or 1).
 */
EventDispatcher.prototype.removeEventListener =
  function(type, callback, context) {
  // using "this" if called w/o context (see addEventListener())
  context = context || this;
  return this.removeEventListeners(type, callback, context);
};

/**
 * Remove event handlers that match function arguments.
 * @param {string=} type Event type to match.
 * @param {function(BoundEvent)=} callback Event handler function to match.
 * @param {*=} context Execution context of the event handler to match.
 * @return {number} Number of listeners removed.
 */
EventDispatcher.prototype.removeEventListeners =
  function(type, callback, context) {
  var listeners = this._listeners;
  var newArr = [];
  var count = 0;
  for (var i = 0; listeners && i < listeners.length; i++) {
    var evt = listeners[i];
    if ((!type || type == evt.type) &&
      (!callback || callback == evt.callback) &&
      (!context || context == evt.context)) {
      count += 1;
    }
    else {
      newArr.push(evt);
    }
  }
  this._listeners = newArr;
  return count;
};


/**
 * Support for handling asynchronous dependencies.
 * Waiter becomes READY and fires 'ready' after any/all dependents are READY.
 * Instantiate directly or use as a base class.
 * Public interface:
 *   waitFor()
 *   startWaiting()
 *   isReady()
 *
 */
function Waiter() {}
Opts.inherit(Waiter, EventDispatcher);

/**
 * Test whether all dependencies are complete, enter ready state if yes.
 */
Waiter.prototype._testReady = function() {
  if (!this._ready && !this._waitCount && this._started) {
    this._ready = true;

    // Child classes can implement handleReadyState()
    this.handleReadyState && this.handleReadyState();
    this.dispatchEvent('ready');
  }
};


/* */
Waiter.prototype.callWhenReady = function(func, args, ctx, priority) {
  this.addEventListener('ready', function(evt) {func.apply(ctx, args);}, ctx, priority);
};


/**
 * Event handler, fired when dependent is ready.
 * @param {BoundEvent} evt Event object.
 */
Waiter.prototype._handleDependentReady = function(evt) {
  if (! this._waitCount) {
    trace('[Waiter.onDependendReady()]',
    'Counting error. Event: ' + Utils.strval(evt) + '; ready? ' + this._ready);
    return;
  }
  this._waitCount -= 1;
  this._testReady();
};


/**
 * Checks if Waiter-enabled object is READY.
 * @return {boolean} True if READY event has fired, else false.
 */
Waiter.prototype.isReady = function() {
  return this._ready == true;
};

/**
 * Wait for a dependent object to become READY.
 * @param {*} obj Class object that implements EventDispatcher.
 * @param {string=} type Event to wait for (optional -- default is 'ready').
 */
Waiter.prototype.waitFor = function(dep, type) {
  if (!dep) {
    trace("[Waiter.waitFor()] missing object; this:", this);
    return this;
  }
  else if (!dep.addEventListener) {
    trace("[Waiter.waitFor()] Need an EventDispatcher; this:", this);
    return this;
  }

  if (!type) {
    type = 'ready';
  }

  // Case: .waitFor() called after this.isReady() becomes true
  if (this._ready) {
    // If object is already READY, ignore....
    if (type == 'ready' && dep.isReady()) {
      return;
    }
    trace("[Waiter.waitFor()] already READY; resetting to isReady() == false;");
    this._ready = false;
    // return this;
    // TODO: prepare test cases to check for logic errors.
  }

  if (type != 'ready'  || dep.isReady() == false) {
    this._waitCount = this._waitCount ? this._waitCount + 1 : 1;
    dep.addEventListener(type, this._handleDependentReady, this);
  }

  return this;
};

/**
 * Start waiting for any dependents to become ready.
 * Should be called after all waitFor() calls.
 */
Waiter.prototype.startWaiting = function(callback, ctx) {
  // KLUDGE: callback may be an BoundEvent if startWaiting is used as an event handler.
  typeof(callback) == 'function' && this.addEventListener('ready', callback, ctx); 
  this._started = true;
  this._testReady();
  return this; // for chaining
};

