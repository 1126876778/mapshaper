/* @requires core */


var Color = {
  enforceRange: function(val, min, max) {
    if (val < min) {
      val = min;
    }
    if (val > max) {
      val = max;
    }
    return val;
  },

  getRGB: function(r, g, b) {
    return (r << 16) | (g << 8) | b;
  },

  getR: function(rgb) {
    return (rgb >> 16) & 0xff;  // mask out alpha values in case argb
  },

  getG: function(rgb) {
    return (rgb >> 8) & 0xff;
  },

  getB: function(rgb) {
    return rgb & 0xff;
  }
};


/**
 * Get the minimum alpha for an overlay channel in front of a bg channel.
 * @param {number} target Target overlay channel color, range [0, 255).
 * @param {number} bg Background channel, range [0, 255).
 * @return {number} Min alpha at which the overlay can be shown, range [0, 1).
 */
Color.getMinChannelAlpha = function(target, bg) {
  var testAlpha = 0.1;
  var modCol = (target - (1 - testAlpha) * bg) / testAlpha;

  var minAlpha = testAlpha;
  if (modCol < 0) {
    minAlpha = 1 - target / bg;
  }
  else if (modCol > 255) {
    minAlpha = (target - bg) / (255 - bg);
  }

  /**
  On a light background, if the bg is darker than the target color value,
  provide a compromise alpha. (TODO: explain this better).
  */
  if (bg < target && bg > 0x66) {
    minAlpha = 0.35;
  }

  return minAlpha;
};

/**
 * Return the minimum alpha that can be used with an overlay color.
 * @param {number} rgb Overlay color.
 * @param {number} bg Background color.
 * @return {number} Alpha value.
 */
Color.getMinAlpha = function(rgb, bg) {
  var targetR = this.getR(rgb);
  var targetG = this.getG(rgb);
  var targetB = this.getB(rgb);

  var bgR = this.getR(bg);
  var bgG = this.getG(bg);
  var bgB = this.getB(bg);

  var alphaR = this.getMinChannelAlpha(targetR, bgR);
  var alphaG = this.getMinChannelAlpha(targetG, bgG);
  var alphaB = this.getMinChannelAlpha(targetB, bgB);
  //trace(' >> new alphas, rgb:', alphaR, alphaG, alphaB);
  return Math.max(alphaR, alphaB, alphaG);
};


Color.adjustColorByAlpha = function(rgb, alpha, bgCol) {
  if (bgCol === undefined) {
    bgCol = 0xffffff;
  }

  var targetR = this.getR(rgb);
  var targetG = this.getG(rgb);
  var targetB = this.getB(rgb);

  var bgR = this.getR(bgCol);
  var bgG = this.getG(bgCol);
  var bgB = this.getB(bgCol);

  var newR = (targetR - (1 - alpha) * bgR) / alpha;
  var newG = (targetG - (1 - alpha) * bgG) / alpha;
  var newB = (targetB - (1 - alpha) * bgB) / alpha;

  newR = Math.round(Utils.clamp(newR, 0, 255));
  newG = Math.round(Utils.clamp(newG, 0, 255));
  newB = Math.round(Utils.clamp(newB, 0, 255));

  return this.getRGB(newR, newG, newB);
};


Color.getOverlayColor = function(rgb, bg, minAlpha) {

  bg = bg == null ? 0xffffff : bg;
  minAlpha = minAlpha == null ? 0 : minAlpha;
  var newAlpha = this.getMinAlpha(rgb, bg);
  if (minAlpha > newAlpha) {
    newAlpha = minAlpha;
  }
  var newRgb = this.adjustColorByAlpha(rgb, newAlpha, bg);
  return {alpha:newAlpha, rgb:newRgb};
};

