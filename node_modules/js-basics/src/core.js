
var A = this.A || {}; // global application parameters
var C = this.C || {}; // global constants



var Env = (function() {
  var inNode = typeof module !== 'undefined' && !!module.exports;
  var inPhantom = !inNode && !!(window.phantom && window.phantom.exit);
  var inBrowser = !inNode; // phantom?
  var ieVersion = inBrowser && /MSIE ([0-9]+)/.exec(navigator.appVersion) && parseInt(RegExp.$1) || NaN;

  return {
    iPhone : inBrowser && !!(navigator.userAgent.match(/iPhone/i)),
    iPad : inBrowser && !!(navigator.userAgent.match(/iPad/i)),
    ieEvents : inBrowser && !!window.attachEvent && !window.addEventListener,
    touchEnabled : inBrowser && ("ontouchstart" in window),
    // canvas: inBrowser && !!Browser.createElement('canvas').getContext,
    canvas: inBrowser && !!document.createElement('canvas').getContext,
    inNode : inNode,
    inPhantom : inPhantom,
    inBrowser: inBrowser,
    ieVersion: ieVersion,
    ie: !isNaN(ieVersion)
  };
})();

var Utils = {
  getUniqueName: function(prefix) {
    var ns = Opts.getNamespace("nytg.map");
    var count = ns.__unique || 0;
    ns.__unique = count + 1;
    return (prefix || "__id_") + count;
  },

  parseUrl: function parseUrl(url) {
    var obj, 
      matches = /^(http):\/\/([^\/]+)(.*)/.exec(url); // TODO: improve
    if (matches) {
      obj = {
        protocol: matches[1],
        host: matches[2],
        path: matches[3]
      };
    }
    else {
      trace("[Utils.parseUrl()] unable to parse:", url);
    }
    return obj;
  },
    
  reduce: function(arr, val, func, ctx) {
    for (var i = 0, len = arr.length; i < len; i++) {
      val = func.call(ctx || null, arr[i], val, i);
    }
    return val;
  },

  repeat: function(func, times) {
    times = times > 0 && times || 1;
    while(times--) {
      func();
    }
  },

  map: function(src, func, ctx) {
    var dest, val;
    if (Utils.isArray(src) || Utils.isNumber(src.length)) { // try to support arguments object
      dest = [];
      for (var i = 0, len = src.length; i < len; i++) {
        val = func.call(ctx, src[i], i);
        dest.push(val);
      }
    } else {
      dest = {};
      for (var key in src) {
        if (src.hasOwnProperty(key)) {
          dest[key] = func.call(ctx, src[key], key); 
        }
      }
    }
    return dest;
  },

  isFunction: function(obj) {
    return typeof obj == 'function';
  },

  isObject: function(obj) {
    return obj === Object(obj); // via underscore
  },

  isArray: function(obj) {
    return obj instanceof Array; // breaks across frames and windows
    // More robust:
    // return Object.constructor.toString.call(obj) == '[object Array]';
  },

  /**
   * from underscore.js; NaN -> true
   */
  isNumber: function(obj) {
    return toString.call(obj) == '[object Number]';
  },

  isString: function(obj) {
    return obj != null && obj.constructor === String; // TODO: replace w/ something better.
  },

  clamp: function(val, min, max) {
    return val < min ? min : (val > max ? max : val);
  },

  interpolate: function(val1, val2, pct) {
    return val1 * (1-pct) + val2 * pct;
  },

  getConstructorName: function(obj) {
    var matches = String(obj.constructor).match(/^function ([^(]+)\(/);
    return matches && matches[1] || "";
  },

  log: function(msg) {
    if (typeof console != "undefined" && console.log) {
      if (console.log.call) {
        console.log.call(console, msg); // Required by ____.
      }
      else {
        console.log(msg);
      }
    }
  },

    
  // Display string representation of an object, for logging, etc.
  // Functions and some objects are converted into a string label.
  // @param validJS Strings are quoted and escaped; if false or undefined, quotes are left
  //   off for cleaner-looking output and long strings are truncated.
  //
  toString: function(obj, validJS) {
    validJS = validJS !== false;
    var type = typeof obj,
        str;

    if (type == 'function') {
      str = '"[function]"';
    } else if (obj == null) { // null or undefined
      str = String(obj);
    } else if (Utils.isArray(obj) || obj.byteLength > 0) { // handle typed arrays (with bytelength property)
      str = '[' + Utils.map(obj, function(o) {return Utils.toString(o, true);}).join(', ') + ']';
    } else if (obj.constructor == Object) { // Show properties of Object instances.
      var parts = [];
      for (var key in obj) {
        var keyStr = /^[A-Za-z_][A-Za-z0-9_]*$/.test(key) ? key : '"' + Utils.addslashes(key) + '"';
        parts.push( keyStr + ':' + Utils.toString(obj[key], true));
      }
      str = '{' + parts.join(', ') + '}';
    } else if (obj.nodeName) { // 
      str = '"[' + obj.nodeName + (obj.id ? " id=" + obj.id : "") + ']"';
    }
    // User-defined objects without a toString() method: Try to get function name from constructor function.
    // Can't assume objects have hasOwnProperty() function (e.g. HTML nodes don't in ie <= 8)
    else if (type == 'object' && obj.hasOwnProperty && !obj.hasOwnProperty('toString') && !obj.constructor.prototype.hasOwnProperty("toString")) {
      str = '"[' + (Utils.getConstructorName(obj) || "unknown object") + ']"';
    } else {  
      // strings, numbers and objects with own "toString" methods. 
      // TODO: make sure that strings made by toString methods are quoted for js.
      str = String(obj);
      if (Utils.isString(obj)) {
        if (validJS) {
          str = '"' + Utils.addslashes(str) + '"';
        } else if (str.length > 400) {
          str = str.substr(0, 400) + " ...";
        }
      }
    }
    return str;
  },

  strval: function(o) {
    return Utils.toString(o, false);
  },

  serialize: function(o) {
    return Utils.toString(o, true);
  },


  // See https://raw.github.com/kvz/phpjs/master/functions/strings/addslashes.js
  //
  addslashes: function(str) {
    return (str + '').replace(/[\\"']/g, '\\$&').replace(/\u0000/g, '\\0');
  }
};



var Opts = {
  copyNewParams : function(targ, src) { return Opts.__copyParams(targ, src, false); },
  copyAllParams : function(targ, src) { return Opts.__copyParams(targ, src, true); },
  updateParams : function(targ, src) { return Opts.__copyParams(targ, src, true, true); },
  __copyParams : function(targ, src, replace, updateOnly) {
    if (!src || !targ) {
      return src || targ;
    }
    for (var key in src) {
      if (!src.hasOwnProperty(key)) {
        continue;
      }
      if (replace || targ[key] === undefined) {
        var val = src[key];
        // Ignore functions added to Object.prototype by old prototype.js or others
        if (Object.prototype[key] === val) {
          continue;
        }

        if (!updateOnly || targ[key] !== undefined) {
          targ[key] = val;
        }
      }
    }
    return targ;
  },


  /**
   * Extends a function's prototype by mixing in objects/functions from a second function.
   */
  extendPrototype : function(targ, src) {
    // Copy src functions/params to targ prototype
    // If there's a collision, retain targ param
    Opts.copyNewParams(targ.prototype, src.prototype || src);
    targ.prototype.constructor = targ;
  },

  /**
   * Pseudoclassical inheritance
   *
   * Inherit from a Parent function:
   *    Opts.inherit(Child, Parent);
   * Call parent's constructor (inside child constructor):
   *    this.__super__([args...]);
   * Call a parent method (when it has been overriden by a same-named function in Child):
   *    this.__super__.<method_name>.call(this, [args...]);
   */
  inherit : function(targ, src) {
    var f = function() {
      // replaced: // if (this.constructor === targ) {
      if (this.__super__ == f) {
        // add __super__ of parent to front of lookup chain
        // so parent class constructor can call its parent using this.__super__
        //
        this.__super__ = src.prototype.__super__; 
        // call parent constructor function. this.__super__ now points to parent-of-parent
        src.apply(this, arguments); 
        // remove temp __super__, expose targ.prototype.__super__ again
        delete this.__super__;
      }
    };

    f.prototype = src.prototype || src; // added || src to allow inheriting from objects as well as functions
    // TODO: extend targ prototype instead of wiping it out -- 
    //   in case inherit() is called after targ.prototype = {stuff}; statement
    targ.prototype = Opts.copyAllParams(new f(), targ.prototype); // 
    targ.prototype.constructor = targ;
    targ.prototype.__super__ = f;
  },

  /*
  subclass : function(src) {
    var f = function() {};
    Opts.inherit(f, src);
    return f;
  },*/

  namespaceExists : function(name) {
    var node = window;
    var parts = name.split('.');
    var exists = Utils.reduce(parts, true, function(part, val) {
      if (val !== false) {
        if (node[part] == null) { // match null or undefined
          val = false;
        }
        else {
          node = node[part];
        }
      }
      return val;
    });
    return exists;
  },

  getNamespace : function(name) {
    var node = window; 
    //var node = typeof Node != "undefined" && Node.inNode ? global : window;
    var parts = name.split('.');

    for (var i=0, len=parts.length; i<len; i++) {
      var part = parts[i];
      if (!part) {
        continue;
      }
      if (!node[part]) {
        node[part] = {};
      }
      node = node[part];
    }

    return node;
  },

  readParam : function(param, defaultVal) {
    return param === undefined ? defaultVal : param;
  },

  extendNamespace : function(ns, obj) {
    var nsObj = typeof ns == 'string' ? Opts.getNamespace(ns) : ns;
    Opts.copyAllParams(nsObj, obj);
  },

  exportObject : function(fullname, obj) {
    var parts = fullname.split('.');
    var oname = parts.pop();
    if (oname) {
      var ns = Opts.getNamespace(parts.join('.'));
      ns[oname] = obj;
    }
  }
};


var trace = function() {
  if (!Env.inBrowser || (typeof Browser) == 'undefined' || Browser.traceEnabled()) {
    Utils.log(Utils.map(arguments, Utils.strval).join(' '));
  }
};

var error = function() {
  var msg = Utils.map(arguments, Utils.strval).join(' ');
  throw new Error(msg);
};

var assert = function(ok) {
  if (!ok) {
    error.apply(null, Array.prototype.slice.call(arguments, 1));
  }
}


/**
 * Support for timing using T.start() and T.stop("message")
 */
var T = {
  stack: [],
  verbose: true,

  /**
   * Start timing.
   */
  start: function(msg) {
    if (T.verbose && msg) trace(T.prefix() + msg);
    T.stack.push(+new Date);
  },

  /**
   * Stop timing.
   * @param {string=} note Optional comment appended to timing message.
   * @return {number} Time elapsed in milliseconds
   */
  stop: function(note) {
    var startTime = T.stack.pop();
    var elapsed = (+new Date - startTime);
    if (T.verbose) {
      var msg =  T.prefix() + elapsed + 'ms';
      if (note) {
        // msg = note + ' ' + msg;
        msg += " " + note;
      }
      trace(msg);      
    }

    return elapsed;
  },

  prefix: function() {
    var str = "- ",
        level = this.stack.length;
    while (level--) {
      str = "-" + str;
    }
    return str;
  }
};


