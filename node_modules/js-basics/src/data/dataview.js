/* @requires core, nodejs */

// Wrapper for DataView class for more convenient sequential reading and writing of
//   numbers; Remembers endianness and read/write position.
// Has convenience methods for copying from buffers, etc.
//
function BinArray(buf, le) {
  if (Node.inNode && buf instanceof Buffer == true) {
    // Since node 0.10, DataView constructor doesn't accept Buffer object,
    //   so need to copy Buffer to ArrayBuffer
    // https://github.com/joyent/node/issues/4884
    // https://github.com/joyent/node/issues/4742
    // http://nodejs.org/api/buffer.html
    buf = BinArray.toArrayBuffer(buf);
  }
  this._buffer = buf;
  this._view = new DataView(buf);
  this._idx = 0;
  this.littleEndian = !!le;
}

BinArray.toArrayBuffer = function(src) {
  if (src instanceof ArrayBuffer) return src;

  var dest = new ArrayBuffer(src.length);
  var view = new Uint8Array(dest);
  for (var i = 0, n=src.length; i < n; i++) {
    view[i] = src[i];
  }
  return dest;
};

BinArray.toNodeBuffer = function(src) {
  if (src instanceof Buffer) return src;
  var view = new Uint8Array(src);
  var dest = new Buffer(view.length);
  for (var i = 0, n=view.length; i < n; i++) {
    dest[i] = view[i];
  }
  return dest;
};


BinArray.bufferSize = function(buf) {
  return (buf instanceof Buffer ? buf.length : buf.byteLength)
};

BinArray.prototype = {
  buffer: function() {
    return this._buffer;
  },

  toNodeBuffer: function() {
    return BinArray.toNodeBuffer(this._buffer);
  },

  dataView: function() {
    return this._view;
  },

  bytesLeft: function() {
    return BinArray.bufferSize(this._buffer) - this._idx;
  },

  readUint8: function() {
    var val = this._view.getUint8(this._idx);
    this._idx++;
    return val;
  },

  readInt8: function() {
    var val = this._view.getInt8(this._idx);
    this._idx++;
    return val; 
  },

  readInt32: function() {
    var val = this._view.getInt32(this._idx, this.littleEndian);
    this._idx += 4;
    return val;
  },

  readUint32: function() {
    var val = this._view.getUint32(this._idx, this.littleEndian);
    this._idx += 4;
    return val;
  },

  writeUint32: function(val) {
    this._view.setUint32(this._idx, val, this.littleEndian);
    this._idx += 4;
  },

  writeInt32: function(val) {
    this._view.setInt32(this._idx, val, this.littleEndian);
    this._idx += 4;
  },

  /*
  readInt16: function(le) {
    var val = this._view.getInt16(this._idx, this.littleEndian);
    this._idx += 2;
    return val;
  },

  readUint16: function(le) {
    var val = this._view.getUint16(this._idx, this.littleEndian);
    this._idx += 2;
    return val;
  },*/

  readUint32Array: function(len) {
    var arr = [];
    for (var i=0; i<len; i++) {
      arr.push(this.readUint32());
    }
    return arr;
  },

  skipBytes: function(bytes) {
    this._idx += (bytes + 0);
    return true;
  },

  clearBytes: function(bytes, clearVal) {
    clearVal = clearVal | 0;
    while (bytes--) {
      this._buffer[this._idx++] = clearVal;
    }
  },

  readFloat64: function() {
    var val = this._view.getFloat64(this._idx, this.littleEndian); 
    this._idx += 8;
    return val;
  },

  writeFloat64: function(val) {
    this._view.setFloat64(this._idx, val, this.littleEndian);
    this._idx += 8;
  },

  readFloat64Array: function(len) {
    var arr = [];
    // TODO: optimize by reading directly from DataView
    for (var i=0; i<len; i++) {
      arr.push(this.readFloat64());
    }
    return arr;
  },

  readPoint: function() {
    return [this.readFloat64(), this.readFloat64()];
  },

  readPointArray: function(len) {
    var arr = [];
    for (var i=0; i<len; i++) {
      arr.push([this.readFloat64(), this.readFloat64()]);
    }
    return arr;
  },

  writePointArray: function(arr) {
    var view = this._view,
        idx = this._idx;
    for (var i=0, len=arr.length; i<len; i++, idx += 8) {
      view.setFloat64(idx, arr[i][0], this.littleEndian);
      view.setFloat64(idx + 4, arr[i][1], this.littleEndian);
    }
    this._idx = idx;
  },

  peek: function() {
    return this._view.getUint8(this._idx);
  },

  position: function(i) {
    if (i != null) {
      this._idx = i;
    }
    return this._idx;
  },

  readCString: function(fixedLen) {
    var str = "";
    var count = 0;
    while(!fixedLen || count < fixedLen) {
      var byteVal = this.readUint8();
      count ++;
      if (byteVal == 0) {
        break;
      }
      str += String.fromCharCode(byteVal);
    }

    if (fixedLen && count < fixedLen) {
      this.skipBytes(fixedLen - count);
    }
    return str;
  },

  identical: function(buf) {
    var bufLen = BinArray.bufferSize(buf);
    var thisLen = BinArray.bufferSize(this._buffer);

    if (thisLen != bufLen) {
      trace("[identical()] Buffers are different sizes.");
      return false;
    }

    for (var i=0; i<bufLen; i++) {
      if (this._buffer[i] !== buf[i]) {
        return false;
      }
    }

    return true;
  },

  writeBuffer: function(src, bytes, startIdx) {
    bytes = bytes || BinArray.bufferSize(src);
    var destIdx = this._idx,
        dest = this._buffer,
        srcIdx = startIdx | 0;

    if (this.bytesLeft() < bytes) error("[writeBuffer()] Buffer overflow; bytesLeft:", this.bytesLeft(), "bytes to write:", bytes);
    while (bytes--) {
      dest[destIdx++] = src[srcIdx++];
    }
    this._idx = destIdx;
  }
};

