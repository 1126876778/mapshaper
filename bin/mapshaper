#!/usr/bin/env node --nouse_idle_notification --expose_gc
//
// Running node with --nouse_idle-notification can improve performance significantly
// with large files. TODO: test that this is still true, since using fewer Arrays
// The gc() calls below are supposed to collect temp. objects from the previous
//   processing stage. Timing gc() gives an indication of overhead from memory management.
//

var optimist = require("optimist"),
    mapshaper = require("../");

var m = mapshaper,
    trace = m.trace,
    assert = m.assert,
    error = m.error,
    MapShaper = m,
    Visvalingam = m.Visvalingam,
    Node = m.Node,
    Utils = m.Utils,
    T = m.T;

var ifile, ifileInfo, ofileInfo = {};

var usage = ""
  + "mapshaper is a tool for simplifying polygon Shapefiles.\n\n"
  + "Usage: mapshaper [options] file\n\n"
  + "Examples:\n\n"
  + "# Use Douglas-Peucker to remove all but 10% of points in a Shapefile.\n"
  + "$ mapshaper --dp -p 0.1 counties.shp\n\n"
  + "# Use Visvalingam to simplify an unprojected Shapefile to 1km resolution.\n"
  + "$ mapshaper --vis -i 1000 -u states.shp "

var opts = optimist
  .usage(usage)

  .options("h", {
    alias: "help",
    describe: "show usage and options",
    'boolean': true
  })

  .options("dp", {
    describe: "Use Douglas-Peucker to simplify",
    'boolean': true
  })

  .options("vis", {
    describe: "Use Visvalingam to simplify",
    'boolean': true
  })

  .options("mod", {
    describe: "Use modified Visvalingam (default)",
    'boolean': true
  })

  /*
  .options("o", {
    describe: "name of output file (with or without suffix)",
  })
  */
  .options("p", {
    alias: "pct",
    describe: "proportion of points to retain (0-1)"
  })

  .options("i", {
    alias: "interval",
    describe: "degree of simplification in units of distance"
  })

  .options("f", {
    alias: "o-format",
    describe: "shapefile|geojson (defaults to input format)",
  })

  .options("u", {
    alias: "unprojected",
    describe: "simplification uses 3D distance in meters",
    'boolean': true
  })

  .options("k", {
    alias: "keep-shapes",
    describe: "prevent small shapes from disappearing",
    'boolean': true
  })

  .options("t", {
    alias: "timing",
    describe: "show execution time of processing steps",
    'boolean': true
  }) 


  /* // TODO
  // prevent points along straight lines from being stripped away, to allow reprojection
  .options("min-segment", {
    describe: "min segment length (no. of segments in largest dimension)",
    default: 0
  })

  .options("remove-null", {
    describe: "remove null shapes",
    default: false
  })

  // round coordinates so output is more compressible (most useful with topojson output)
  .options("q", {
    alias: "quantize",
    describe: "max number of distinct x-axis or y-axis coordinates",
  })

  .options("l", {
    alias: "log",
    describe: "write debugging information to <filename>.log",
    default: false
  })

  .options("v", {
    alias: "verbose",
    describe: "show verbose messages",
    default: false
  }) 

  .options("", {
    alias: "-",
    describe: "output to /dev/stdout",
    default: false
  })*/


  .check(function(opts) {
    if (opts.h) {
      optimist.showHelp();
      process.exit(0);
    }

    var argv = opts._;

    // check input file and format
    // TODO: accept stdin input, infer format from the data
    if (argv.length == 0) {
      error("Missing an input file.")
      ifile = "/dev/stdin";
    }
    else {
      ifile = argv[0];
      ifileInfo = Node.getFileInfo(ifile);
      if (!ifileInfo.exists) throw new Error("File not found (" + ifile + ")");
      if (ifileInfo.ext != 'shp') throw new Error("Input filename must match *.shp");
      if (opts.f) opts.f = opts.f.toLowerCase();
      assert(!opts.f || opts.f == 'shapefile' || opts.f == 'topojson' || opts.f == 'geojson', "Invalid output format");
    }

    // validate interval
    opts.i = opts.i || 0;
    assert(!isNaN(opts.i) && opts.i >= 0, "-i (--interval) option requires a non-negative number");

    // validate pct retained
    opts.p = opts.p || 1;
    assert(opts.p > 0 && opts.p <= 1, "-p (--pct) option should be in the range (0,1]");
  })
  .argv;

var simplifyOn = opts.i > 0 || opts.p < 1;
var method = "mod"; // default method
if (opts.dp) {
  method = "dp";
} else if (opts.vis) {
  method = "vis";
}

if (opts.f) {
  ofileInfo.type = opts.f;
} 
else if (ifileInfo.ext == "shp") {
  ofileInfo.type = "shapefile";
} 
else {
  error("Missing output format.");
}


T.verbose = opts.t;
T.start("Starting timing");

T.start();
var read = ifile == "/dev/stdin" ? MapShaper.importFromStream : MapShaper.importFromFile;
var importData = read(ifile);
T.stop("Shapefile import");

T.start();
var topoData = MapShaper.buildArcTopology(importData); // obj.xx, obj.yy, obj.partIds, obj.shapeIds
T.stop("Topology conversion");

importData = null; // don't need this anymore, gc can take it.


T.start();
Node.gc();
T.stop("gc()");

if (simplifyOn) {
  T.start();
  var simplifiedArcs,
      arcs = topoData.arcs,
      calculator;

  var simplifyOpts = {
    spherical: !!opts.u
  };

  if (method == 'dp') {
    calculator = m.DouglasPeucker.calcArcData;
    simplifiedArcs =MapShaper.simplifyArcs(arcs, calculator, simplifyOpts);
  }
  else if (method == 'vis') {
    var intervalScale = 0.65; // TODO: tune this constant (linear scale when converting Visv. area metric to distance units);
    calculator = Visvalingam.getArcCalculator(Visvalingam.standardMetric, Visvalingam.standardMetric3D, intervalScale);
    simplifiedArcs = MapShaper.simplifyArcs(arcs, calculator, simplifyOpts);
  }
  else if (method == 'mod') {
    intervalScale = 0.65 // TODO: tune this
    calculator = Visvalingam.getArcCalculator(Visvalingam.specialMetric, Visvalingam.specialMetric3D, intervalScale);
    simplifiedArcs = MapShaper.simplifyArcs(arcs, calculator, simplifyOpts);
  }
  else {
    error("Unknown method:",method);
  }
  T.stop("Simplification complete");

  T.start();
  Node.gc();
  T.stop("gc()");

  T.start();
  var thinningOpts = {
    minPoints: opts.k && topoData.arcMinPointCounts || null
  };
  if (opts.p < 1) {
    topoData.arcs = MapShaper.thinArcsByPct(topoData.arcs, simplifiedArcs, opts.p, thinningOpts);
  } else if (opts.i > 0) {
    topoData.arcs = MapShaper.thinArcsByInterval(topoData.arcs, simplifiedArcs, opts.i, thinningOpts);
  }
  T.stop("Thinning complete");
}

T.start();
Node.gc();
T.stop("gc()");


// OUTPUT FILE
//
ofileInfo.base = ifileInfo.base + "-mshp"; // TODO: use user-supplied name, if present
var ibase = ifileInfo.directory + "/" + ifileInfo.base,
    obase = ofileInfo.base; // currently outputs to same cwd

// TODO: make sure we're not overwriting the original file/s

if (ofileInfo.type == "geojson") {
  T.start();
  var geoJSON = MapShaper.exportGeoJSON(topoData);
  T.stop("Export GeoJSON");
  Node.writeFile(ofileInfo.base + ".json", geoJSON);
}
else if (ofileInfo.type == "shapefile") {
  T.start();
  var shpData = MapShaper.exportShp(topoData);
  T.stop("Export Shapefile");

  var prjFile = ibase + ".prj",
      dbfFile = ibase + ".dbf";
  Node.writeFile(obase + ".shp", shpData.shp);
  Node.writeFile(obase + ".shx", shpData.shx);
  if (Node.fileExists(prjFile)) Node.copyFile(prjFile, obase + ".prj");
  if (Node.fileExists(dbfFile)) Node.copyFile(dbfFile, obase + ".dbf");

  // if no simplification and input/output both shapefile, see if output
  // is identical to input (to test for topology errors)
  if (ifileInfo.ext == "shp" && !simplifyOn) {
    var originalShp = new m.BinArray(Node.readFile(ifileInfo.path)),
        isSame = originalShp.identical(shpData.shp);
    trace("* No simplification; checking that input and output files are identical:", isSame);
  }
}

T.stop("Total time");
