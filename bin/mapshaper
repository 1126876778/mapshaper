#!/usr/bin/env node --nouse_idle_notification --expose_gc
//
// Running node with --nouse_idle-notification can improve performance significantly
// with large files. TODO: test that this is still true, since using fewer Arrays
// The gc() calls below are supposed to collect temp. objects from the previous
//   processing stage. Timing gc() gives an indication of overhead from memory management.
//

var mapshaper = require("../"),
    m = mapshaper,
    trace = m.trace,
    assert = m.assert,
    error = m.error,
    Visvalingam = m.Visvalingam,
    Node = m.Node,
    Utils = m.Utils,
    T = m.T;

var usage = ""
  + "Usage: mapshaper [options] file\n\n"
  + "Examples:\n\n"
  + "# Use Douglas-Peucker to remove all but 10% of points in a Shapefile.\n"
  + "$ mapshaper --dp -p 0.1 counties.shp\n\n"
  + "# Use Visvalingam to simplify an unprojected Shapefile to 1km resolution.\n"
  + "$ mapshaper --vis -i 1000 -u states.shp"

var optimist = require("optimist")
optimist.usage(usage)

  .options("h", {
    alias: "help",
    describe: "show usage and options",
    'boolean': true
  })

  .options("dp", {
    describe: "Use Douglas-Peucker to simplify",
    'boolean': true
  })

  .options("vis", {
    describe: "Use Visvalingam to simplify",
    'boolean': true
  })

  .options("mod", {
    describe: "Use modified Visvalingam (default)",
    'boolean': true
  })

  /*
  .options("o", {
    describe: "name of output file (with or without suffix)",
  })
  */
  .options("p", {
    alias: "pct",
    describe: "proportion of points to retain (0-1)"
  })

  .options("i", {
    alias: "interval",
    describe: "degree of simplification in units of distance"
  })

  .options("f", {
    alias: "o-format",
    describe: "shapefile|geojson (defaults to input format)",
  })

  .options("u", {
    alias: "unprojected",
    describe: "simplification uses 3D distance in meters",
    'boolean': true
  })

  .options("k", {
    alias: "keep-shapes",
    describe: "prevent small shapes from disappearing",
    'boolean': true
  })

  .options("t", {
    alias: "timing",
    describe: "show execution time of processing steps",
    'boolean': true
  }) 

  .options("shp-test", {
    describe: "test if .shp can be regenerated from topology",
    'boolean': true
  })

  /* // TODO
  // prevent points along straight lines from being stripped away, to allow reprojection
  .options("min-segment", {
    describe: "min segment length (no. of segments in largest dimension)",
    default: 0
  })

  .options("remove-null", {
    describe: "remove null shapes",
    default: false
  })

  // round coordinates so output is more compressible (most useful with topojson output)
  .options("q", {
    alias: "quantize",
    describe: "max number of distinct x-axis or y-axis coordinates",
  })

  .options("l", {
    alias: "log",
    describe: "write debugging information to <filename>.log",
    default: false
  })

  .options("v", {
    alias: "verbose",
    describe: "show verbose messages",
    default: false
  }) 

  .options("", {
    alias: "-",
    describe: "output to /dev/stdout",
    default: false
  })*/
  .check(function(argv) {
    opts = mapshaper.validateArgv(argv, optimist);
  })
  .argv;

var info = {},
    opts;

T.verbose = opts.t;
T.start("Starting timing");

T.start();
var importData = mapshaper.importFromFile(opts.input_file);
T.stop("Shapefile import");

T.start();
var topoData = mapshaper.buildArcTopology(importData); // obj.xx, obj.yy, obj.partIds, obj.shapeIds
T.stop("Topology conversion");

// Opts.copyAllParams(info, importData);
// Opts.copyAllParams(info, topoData)

importData = null; // don't need this anymore, gc can take it.

T.start();
Node.gc();
T.stop("gc()");

if (opts.use_simplification) {
  T.start();
  var simplifyData,
      arcs = topoData.arcs,
      calculator;

  var simplifyOpts = {
    spherical: !!opts.u
  };

  if (opts.method == 'dp') {
    calculator = m.DouglasPeucker.calcArcData;
    simplifiedArcs = mapshaper.simplifyArcs(arcs, calculator, simplifyOpts);
  }
  else if (opts.method == 'vis') {
    var intervalScale = 0.65; // TODO: tune this constant (linear scale when converting Visv. area metric to distance units);
    calculator = Visvalingam.getArcCalculator(Visvalingam.standardMetric, Visvalingam.standardMetric3D, intervalScale);
    simplifiedArcs = mapshaper.simplifyArcs(arcs, calculator, simplifyOpts);
  }
  else if (opts.method == 'mod') {
    intervalScale = 0.65 // TODO: tune this
    calculator = Visvalingam.getArcCalculator(Visvalingam.specialMetric, Visvalingam.specialMetric3D, intervalScale);
    simplifiedArcs = mapshaper.simplifyArcs(arcs, calculator, simplifyOpts);
  }
  else {
    stop("Unknown simplification method:", method);
  }
  T.stop("Simplification complete");

  T.start();
  Node.gc();
  T.stop("gc()");

  T.start();
  var thinningOpts = {
    minPoints: opts.k && topoData.arcMinPointCounts || null
  };
  if (opts.p < 1) {
    topoData.arcs = mapshaper.thinArcsByPct(topoData.arcs, simplifiedArcs, opts.p, thinningOpts);
  } else if (opts.i > 0) {
    topoData.arcs = mapshaper.thinArcsByInterval(topoData.arcs, simplifiedArcs, opts.i, thinningOpts);
  }
  T.stop("Thinning complete");
}

T.start();
Node.gc();
T.stop("gc()");

// Output... TODO: make sure not overwriting input file

if (opts.output_format == "geojson") {
  T.start();
  var geoJSON = mapshaper.exportGeoJSON(topoData);
  T.stop("Export GeoJSON");
  Node.writeFile(opts.output_path_base + ".json", geoJSON);
}
else if (opts.output_format == "shapefile") {
  T.start();
  var shpData = mapshaper.exportShp(topoData);
  T.stop("Export Shapefile");

  if (opts.test_shp_output) {
    // check if output .shp data is identical to input (e.g. to test for topology errors)
    var originalShp = new m.BinArray(Node.readFile(opts.input_file)),
        passes = originalShp.identical(shpData.shp),
        msg = passes ?
          "\u001b[32m \u2713\u001b[0m Output .shp is identical to original." :
          "\u001b[31m \u2717\u001b[0m Ouput .shp doesn't match original.";
    trace(msg);
  }
  else {
    var obase = opts.output_path_base,
        prjFile = obase + ".prj",
        dbfFile = obase + ".dbf";
    Node.writeFile(obase + ".shp", shpData.shp);
    Node.writeFile(obase + ".shx", shpData.shx);
    if (Node.fileExists(prjFile)) Node.copyFile(prjFile, obase + ".prj");
    if (Node.fileExists(dbfFile)) Node.copyFile(dbfFile, obase + ".dbf");
  }
}

info.processing_time = T.stop("Total time");

// TODO: option to print a report based on data collected in info object.
