#!/usr/bin/env node

var mapshaper = require("../"),
    utils = mapshaper.utils,
    opts = mapshaper.cli.getOpts(),
    inputList = opts.input_files;

mapshaper.enableLogging();
mapshaper.T.start("Start timing");

if (opts.join_file) {
  // need to use a callback if joining a file, because csv parser is asynchronous
  mapshaper.importJoinTableAsync(opts.join_file, opts, function(table) {
    opts.join_table = table;
    procFiles(inputList, opts);
  });
} else {
  procFiles(inputList, opts);
}

function procFiles(files, opts) {
  var mergedData, mergedName;
  if (opts.merge_files || opts.combine_files) {
    mergedData = mapshaper.mergeFiles(files, opts);
    if (opts.merge_files) {
      mergedData.layers = mapshaper.mergeLayers(mergedData.layers);
    }
    if (!opts.output_file_base) {
      opts.output_file_base = utils.getMergedFileBase(files) || "merged";
    }
    procDataset(mergedData, opts);
  } else {
    files.forEach(function(ifile) {
      var fileOpts = utils.extend({}, opts); // copy common options
      fileOpts.input_files = [ifile];
      if (!fileOpts.output_file_base) {
        fileOpts.output_file_base = utils.parseLocalPath(ifile).basename;
      }
      var data = mapshaper.importFromFile(ifile, fileOpts);
      procDataset(data, fileOpts);
    });
  }
  mapshaper.T.stop("Total time");
}

function procDataset(importData, opts) {
  var arcData = importData.arcs,
      layers = importData.layers,
      info = {};

  // Update input/output format with information found during importing
  // (command line info is insufficient to distinguish topojson and geojson)
  opts.input_format = opts.input_format || importData.info.input_format;
  opts.output_format = opts.output_format || opts.input_format;

  if (opts.join_table) {
    mapshaper.joinTableToLayers(layers, opts.join_table, opts.join_keys, opts.join_fields);
    // kludge to let join table be gc'd
    if (inputList.length == 1) opts.join_table = null;
  }

  if (!opts.input_format) error("Unknown input file format");

  if (opts.use_simplification) {
    mapshaper.simplifyPaths(arcData, opts.simplify_method, opts.force2D);

    if (opts.keep_shapes) {
      mapshaper.protectShapes(arcData, layers);
    }

    if (utils.isNumber(opts.simplify_pct)) {
      arcData.setRetainedPct(opts.simplify_pct);
    } else if (opts.simplify_interval) {
      arcData.setRetainedInterval(opts.simplify_interval);
    }

    if (opts.repair) {
      utils.extend(info, mapshaper.findAndRepairIntersections(arcData));
      mapshaper.cli.printRepairMessage(info, opts);
    }
  }

  if (opts.filter) {
    mapshaper.filterLayers(layers, arcData, opts.filter);
  }

  if (opts.expression) {
    mapshaper.evaluateLayers(layers, arcData, opts.expression);
  }

  if (opts.field_map) {
    mapshaper.filterFields(layers, opts);
  }

  /*
  // need to handle holes correctly before enabling this
  if (opts.explode) {
    mapshaper.explodeLayers(layers, arcData);
  }
  */

  if (opts.split) {
    layers = mapshaper.splitLayers(layers, arcData, opts.split);
  }

  if (opts.subdivide) {
    layers = mapshaper.subdivideLayers(layers, arcData, opts.subdivide);
  }

  if (opts.dissolve) {
    layers = mapshaper.dissolveLayers(layers, arcData, opts.dissolve, opts);
  }

  if (opts.postfilter) {
    mapshaper.filterLayers(layers, arcData, opts.postfilter);
  }

  if (opts.innerlines) {
    layers = mapshaper.convertLayersToInnerLines(layers, arcData);
  } else if (opts.lines) {
    layers = mapshaper.convertLayersToTypedLines(layers, arcData, opts.lines);
  }

  // filter & merge arcs if outputting topojson and arcs may have changed
  // TODO: decide if this belongs here or in topojson output function
  if (opts.output_format == 'topojson' && (opts.innerlines || opts.dissolve)) {
    arcData = mapshaper.dissolveArcs(layers, arcData);
  }

  if (opts.recombine) {
    layers = mapshaper.mergeLayers(layers);
  }

  if (opts.info) {
    mapshaper.printInfo(layers, arcData, opts, info);
    return;
  }

  if (opts.split_rows && opts.split_cols) {
    if (layers.length != 1) error("Split-on-grid expects one layer");
    layers = mapshaper.splitOnGrid(layers[0], arcData, opts.split_rows, opts.split_cols);
    // TODO: find sensible way of generating topojson with multiple layer-objects
    // (e.g. --topojson-merge option
    opts.topojson_divide = true;
  }

  var exports = mapshaper.exportFileContent(layers, arcData, opts);

  // Copy prj file, if both importing and exporting as shapefile
  // TODO: move this elsewhere
  if (opts.output_format == 'shapefile' && opts.input_format == 'shapefile') {
    var prjFile = mapshaper.cli.replaceFileExtension(importData.info.input_files[0], 'prj'),
        shpFiles = utils.filter(exports, function(o) {return o.extension == 'shp'});

    if (mapshaper.cli.fileExists(prjFile)) {
      shpFiles.forEach(function(o) {
        exports.push({
          content: mapshaper.cli.readFile(prjFile, 'utf-8'),
          extension: 'prj',
          filebase: o.filebase
        });
      });
    }
  }

  var paths = mapshaper.cli.getOutputPaths(exports, opts.output_directory, opts.output_extension);
  exports.forEach(function(obj, i) {
    var path = paths[i];
    mapshaper.cli.writeFile(path, obj.content);
    console.log("Wrote " + path);
  });
}
